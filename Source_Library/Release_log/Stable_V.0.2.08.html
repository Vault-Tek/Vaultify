<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vaultify - Password Manager (Hardened)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .card { transform-style: preserve-3d; transition: transform 0.1s ease-out; }
    .password-container { max-height: 300px; overflow-y: scroll; scrollbar-width: none; }
    .password-container::-webkit-scrollbar { display: none; }
    .search-container { display: none; margin-top: 10px; }
    .password-container li { background-color: #1F2937; padding: 12px; border-radius: 8px; display: flex; flex-direction: column; margin-bottom: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .btn { background-color: #2d3748; color: #edf2f7; padding: 4px 10px; border-radius: 4px; font-size: 0.75rem; margin: 0 4px; border: none; cursor: pointer; }
    .btn-view,.btn-edit,.btn-delete { background-color: #2d3748; }
    .action-btns { display: flex; justify-content: flex-start; align-items: center; }
    .action-btns button { margin-right: 5px; }
    .no-match-card { background-color: #1F2937; padding: 12px; border-radius: 8px; text-align: center; margin-top: 10px; color: #edf2f7; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .notification { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background-color: #1F2937; color: #edf2f7; padding: 12px 24px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: none; z-index: 1000; }
    .error { background-color: #1F2937; }
    .lock-animation { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000; font-size: 3rem; animation: lockAnimation 2s infinite; }
    @keyframes lockAnimation { 0% { transform: translate(-50%, -50%) scale(1);} 50% { transform: translate(-50%, -50%) scale(1.2);} 100% { transform: translate(-50%, -50%) scale(1);} }
    .hidden { display: none; }
    .slide-menu { position: fixed; top: 0; left: -300px; width: 300px; height: 100%; background-color: #1F2937; color: #edf2f7; padding: 20px; box-shadow: 2px 0 5px rgba(0,0,0,0.5); transition: left 0.3s ease; z-index: 3000; display: flex; flex-direction: column; gap: 20px; }
    .slide-menu.open { left: 0; }
    .menu-option { cursor: pointer; padding: 10px; border-radius: 4px; transition: background-color 0.3s; }
    .menu-option:hover { background-color: #2d3748; }
    .menu-toggle { position: fixed; top: 20px; left: 20px; z-index: 3100; cursor: pointer; width: 30px; height: 30px; display: flex; flex-direction: column; justify-content: space-between; display: none; }
    .menu-toggle div { background-color: #edf2f7; height: 4px; border-radius: 2px; transition: transform 0.3s ease, opacity 0.3s ease; }
    /* Preserve original id reference (no functional impact) */
    #details-${index} { margin-top: 10px; padding-top: 10px; border-top: 1px solid #444; }
  </style>
</head>
<body class="bg-gray-900 text-white flex justify-center items-center h-screen" onmousemove="handleMouseMove(event)" onclick="closeMenu(event)">
  <div id="notification" class="notification">Success</div>
  <div id="errorNotification" class="notification error">Error</div>
  <div id="lockAnimation" class="lock-animation hidden">üîí</div>

  <!-- Slide-Out Menu -->
  <div class="slide-menu" id="slideMenu">
    <div class="menu-option" onclick="exportData()">Export Data</div>
    <div class="menu-option" onclick="importData()">Import Data</div>
    <div class="menu-option" onclick="logOut()">Log Out</div>
  </div>
  <div class="menu-toggle" id="menuToggle" onclick="toggleMenu(event)">
    <div></div><div></div><div></div>
  </div>

  <div class="w-96 p-6 bg-gray-800 rounded-lg shadow-lg card" id="mainCard">
    <div id="loginForm" class="login-container flex flex-col items-center">
      <h2 class="text-xl font-bold mb-4 text-center">Login to Vaultify üîí</h2>
      <input id="loginUsername" type="text" placeholder="Username" class="input-field w-full p-2 mb-2 rounded bg-gray-700 text-white" />
      <input id="loginPassword" type="password" placeholder="Password" class="input-field w-full p-2 mb-2 rounded bg-gray-700 text-white" />
      <button onclick="login()" class="login-btn w-full bg-blue-500 p-2 rounded mt-2">Log In</button>
      <p class="mt-2 text-center text-gray-400">Don't have an account? <span onclick="toggleForm('signup')" class="cursor-pointer text-blue-400">Create an Account üîë</span></p>
    </div>

    <div id="signupForm" class="signup-container flex flex-col items-center hidden">
      <h2 class="text-xl font-bold mb-4 text-center">Create an Account üîë</h2>
      <input id="signupUsername" type="text" placeholder="Username" class="input-field w-full p-2 mb-2 rounded bg-gray-700 text-white" />
      <input id="signupPassword" type="password" placeholder="Password" class="input-field w-full p-2 mb-2 rounded bg-gray-700 text-white" />
      <button onclick="signup()" class="signup-btn w-full bg-blue-500 p-2 rounded mt-2">Sign Up</button>
      <p class="mt-2 text-center text-gray-400">Already have an account? <span onclick="toggleForm('login')" class="cursor-pointer text-blue-400">Log In</span></p>
    </div>

    <div id="passwordManager" class="password-manager hidden">
      <h2 class="text-xl font-bold mb-4 text-center">Vaultify üîí</h2>
      <input id="site" type="text" placeholder="Website" class="w-full p-2 mb-2 rounded bg-gray-700 text-white" />
      <input id="username" type="text" placeholder="Username" class="w-full p-2 mb-2 rounded bg-gray-700 text-white" />
      <input id="password" type="password" placeholder="Password" class="w-full p-2 mb-2 rounded bg-gray-700 text-white" oninput="toggleViewButton()" />
      <button onclick="savePassword()" class="w-full bg-blue-500 p-2 rounded">Save</button>
      <button onclick="togglePasswordList()" class="w-full bg-gray-700 p-2 rounded mt-4">Saved Passwords ‚ñº</button>
      <div id="passwordContainer" class="password-container bg-gray-700 rounded mt-2 p-2" style="display:none;">
        <div id="searchContainer" class="search-container">
          <input id="searchInput" type="text" placeholder="Search for website or username" class="w-full p-2 mb-2 rounded bg-gray-600 text-white" oninput="searchPasswords()" />
        </div>
        <ul id="passwordList" class="mt-2"></ul>
        <div id="noMatchCard" class="no-match-card hidden">No passwords match your search</div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // HARDENED CRYPTO (WebCrypto)
    // =========================
    // - AES-GCM 256 with random 12-byte IV per entry
    // - PBKDF2 with SHA-256 and high iterations
    // - No master password or key in localStorage
    // - Only encrypted blobs stored

    const KDF_ITERATIONS = 250000; // high cost for offline cracking
    const KDF_SALT_BYTES = 16; // 128-bit salt
    const IV_BYTES = 12; // 96-bit IV for AES-GCM

    let masterKey = null; // CryptoKey (in-memory only)

    // Utility: random bytes
    function randomBytes(len) {
      const arr = new Uint8Array(len);
      crypto.getRandomValues(arr);
      return arr;
    }

    // Utility: conversions
    function bufToBase64(buf) { return btoa(String.fromCharCode(...new Uint8Array(buf))); }
    function base64ToBuf(b64) { return Uint8Array.from(atob(b64), c => c.charCodeAt(0)); }
    async function sha256(buf) { const d = await crypto.subtle.digest('SHA-256', buf); return new Uint8Array(d); }

    // Derive a key from password + salt
    async function deriveKey(password, salt, iterations = KDF_ITERATIONS) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits']
      );
      const key = await crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );
      return key;
    }

    // Export a key to raw bytes for hashing/verifier
    async function exportKeyRaw(key) {
      const raw = await crypto.subtle.exportKey('raw', key);
      return new Uint8Array(raw);
    }

    // Encrypt text with AES-GCM using masterKey
    async function encryptText(plaintext, key) {
      const iv = randomBytes(IV_BYTES);
      const enc = new TextEncoder();
      const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc.encode(plaintext));
      return { iv: bufToBase64(iv), data: bufToBase64(ct) };
    }

    // Decrypt text
    async function decryptText(obj, key) {
      const iv = base64ToBuf(obj.iv);
      const ct = base64ToBuf(obj.data);
      const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
      const dec = new TextDecoder();
      return dec.decode(pt);
    }

    // Vault config helpers
    function getVaultConfig() {
      const raw = localStorage.getItem('vault_config');
      return raw ? JSON.parse(raw) : null;
    }
    function setVaultConfig(cfg) {
      localStorage.setItem('vault_config', JSON.stringify(cfg));
    }

    // Store session key material (tab-scoped) to preserve UX without putting it in localStorage
    async function cacheSessionKey(key) {
      const raw = await exportKeyRaw(key);
      sessionStorage.setItem('session_key', bufToBase64(raw));
    }
    async function loadSessionKey() {
      const b64 = sessionStorage.getItem('session_key');
      if (!b64) return null;
      const raw = base64ToBuf(b64);
      return await crypto.subtle.importKey('raw', raw, { name: 'AES-GCM' }, true, ['encrypt', 'decrypt']);
    }
    function clearSessionKey() { sessionStorage.removeItem('session_key'); }

    // =========================
    // ORIGINAL APP LOGIC (kept UI/UX)
    // =========================

    let editingIndex = -1;
    let viewedIndices = new Set();

    window.onload = async function() {
      const savedLoggedIn = localStorage.getItem('loggedIn');
      // Try to restore session key for UX similar to original auto-login
      masterKey = await loadSessionKey();

      if (savedLoggedIn === 'true') {
        toggleLoginForm();
        document.getElementById('menuToggle').style.display = 'flex';
        await displayPasswords();
      } else {
        document.getElementById('menuToggle').style.display = 'none';
      }
    }

    function toggleForm(formType) {
      clearInputFields();
      if (formType === 'login') {
        document.getElementById('loginForm').style.display = 'flex';
        document.getElementById('signupForm').style.display = 'none';
      } else if (formType === 'signup') {
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('signupForm').style.display = 'flex';
      }
      document.getElementById('menuToggle').style.display = 'none';
    }

    function clearInputFields() {
      ['loginUsername','loginPassword','signupUsername','signupPassword','site','username','password']
        .forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });
    }

    function showNotification(message) {
      const notification = document.getElementById('notification');
      notification.innerText = message; notification.style.display = 'block';
      setTimeout(() => { notification.style.display = 'none'; }, 3000);
    }
    function showErrorNotification(message) {
      const errorNotification = document.getElementById('errorNotification');
      errorNotification.innerText = message; errorNotification.style.display = 'block';
      setTimeout(() => { errorNotification.style.display = 'none'; }, 3000);
    }

    // =========================
    // SIGNUP / LOGIN (Hardened)
    // =========================

    async function signup() {
      const signupUsername = document.getElementById('signupUsername').value.trim();
      const signupPassword = document.getElementById('signupPassword').value;
      if (!signupUsername || !signupPassword) { showErrorNotification('Please enter both username and password'); return; }

      const salt = randomBytes(KDF_SALT_BYTES);
      const key = await deriveKey(signupPassword, salt);
      const keyRaw = await exportKeyRaw(key);
      const verifier = await sha256(keyRaw.buffer);

      setVaultConfig({
        version: 1,
        username: signupUsername, // store as plain for simple UX; could encrypt with a hint if desired
        kdf: { salt: bufToBase64(salt), iterations: KDF_ITERATIONS },
        verifier: bufToBase64(verifier)
      });

      // Initialize empty vault
      localStorage.setItem('passwords', JSON.stringify([]));

      clearInputFields();
      toggleForm('login');
      showNotification('Account created successfully');
    }

    async function login() {
      const loginUsername = document.getElementById('loginUsername').value.trim();
      const loginPassword = document.getElementById('loginPassword').value;
      if (!loginUsername || !loginPassword) { showErrorNotification('Please enter both username and password'); return; }

      const cfg = getVaultConfig();
      if (!cfg) { showErrorNotification('Invalid username or password'); return; }
      if (cfg.username !== loginUsername) { showErrorNotification('Invalid username or password'); return; }

      const salt = base64ToBuf(cfg.kdf.salt);
      const key = await deriveKey(loginPassword, salt, cfg.kdf.iterations || KDF_ITERATIONS);
      const keyRaw = await exportKeyRaw(key);
      const hash = await sha256(keyRaw.buffer);
      const ok = bufToBase64(hash) === cfg.verifier;
      if (!ok) { showErrorNotification('Invalid username or password'); return; }

      // Successful login animation and state
      const lockAnimation = document.getElementById('lockAnimation');
      const mainCard = document.getElementById('mainCard');
      mainCard.classList.add('hidden'); lockAnimation.classList.remove('hidden');

      setTimeout(async () => {
        lockAnimation.classList.add('hidden');
        localStorage.setItem('loggedIn','true');
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('signupForm').style.display = 'none';
        document.getElementById('passwordManager').style.display = 'block';
        mainCard.classList.remove('hidden');
        document.getElementById('menuToggle').style.display = 'flex';

        masterKey = key; // keep only in memory
        await cacheSessionKey(masterKey); // tab-scoped to preserve UX
        viewedIndices.clear();
        await displayPasswords();
        showNotification('Logged in successfully');
      }, 2000);
    }

    function toggleLoginForm() {
      const loginForm = document.getElementById('loginForm');
      const signupForm = document.getElementById('signupForm');
      const passwordManager = document.getElementById('passwordManager');
      loginForm.style.display = 'none'; signupForm.style.display = 'none'; passwordManager.style.display = 'block';
    }

    // =========================
    // PASSWORD CRUD (encrypted at rest)
    // =========================

    async function savePassword() {
      const site = document.getElementById('site').value.trim();
      const username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value;
      if (!site || !username || !password) return;
      if (!masterKey) { showErrorNotification('Session locked. Please log in again.'); return; }

      const entryPlain = JSON.stringify({ site, username, password });
      const encObj = await encryptText(entryPlain, masterKey);

      let passwords = JSON.parse(localStorage.getItem('passwords')) || [];
      const storedEntry = { iv: encObj.iv, data: encObj.data };
      if (editingIndex === -1) { passwords.push(storedEntry); } else { passwords[editingIndex] = storedEntry; editingIndex = -1; }
      localStorage.setItem('passwords', JSON.stringify(passwords));

      await displayPasswords();
      clearInputFields();
    }

    async function displayPasswords() {
      const passwordList = document.getElementById('passwordList');
      passwordList.innerHTML = '';
      const passwords = JSON.parse(localStorage.getItem('passwords')) || [];

      for (let index = 0; index < passwords.length; index++) {
        let decryptedSite = 'üîí Locked';
        let decryptedUsername = 'üîí Locked';
        let passwordMasked = '*'.repeat(8);

        if (masterKey) {
          try {
            const obj = passwords[index];
            const json = await decryptText(obj, masterKey);
            const parsed = JSON.parse(json);
            decryptedSite = parsed.site;
            decryptedUsername = parsed.username;
            // reveal state handled by revealPassword()
          } catch (e) {
            decryptedSite = '‚ö†Ô∏è Corrupt entry';
            decryptedUsername = '';
          }
        }

        passwordList.innerHTML += `
          <li class='bg-gray-800 p-2 rounded mt-2 flex flex-col'>
            <div class='flex justify-between items-center'>
              <strong>${escapeHtml(decryptedSite)}</strong>
              <button onclick='togglePasswordDetails(${index})' class='btn btn-view' id='toggleBtn-${index}'>${viewedIndices.has(index) ? 'üîì' : 'üîí'}</button>
            </div>
            <div id='details-${index}' class='${viewedIndices.has(index) ? '' : 'hidden'}'>
              <div>Username: ${escapeHtml(decryptedUsername)}</div>
              <div>Password: <span id='password-${index}'>${passwordMasked}</span></div>
              <div class='action-btns'>
                <button onclick='revealPassword(${index})' class='btn btn-view' id='viewBtn-${index}'>View</button>
                <button onclick='editPassword(${index})' class='btn btn-edit hidden' id='editBtn-${index}'>‚úèÔ∏è</button>
                <button onclick='deletePassword(${index})' class='btn btn-delete' id='deleteBtn-${index}'>üóë</button>
              </div>
            </div>
          </li>`;
      }
    }

    function togglePasswordDetails(index) {
      const details = document.getElementById(`details-${index}`);
      const toggleBtn = document.getElementById(`toggleBtn-${index}`);
      const passwordField = document.getElementById(`password-${index}`);
      const viewBtn = document.getElementById(`viewBtn-${index}`);
      const editBtn = document.getElementById(`editBtn-${index}`);
      const deleteBtn = document.getElementById(`deleteBtn-${index}`);

      if (details.classList.contains('hidden')) {
        details.classList.remove('hidden'); toggleBtn.innerText = 'üîì'; viewedIndices.add(index);
      } else {
        details.classList.add('hidden'); toggleBtn.innerText = 'üîí'; passwordField.innerText = '*'.repeat(8);
        viewBtn.innerText = 'View'; editBtn.classList.add('hidden'); deleteBtn.classList.remove('hidden'); viewedIndices.delete(index);
      }
    }

    async function revealPassword(index) {
      if (!masterKey) { showErrorNotification('Session locked. Please log in again.'); return; }
      let passwords = JSON.parse(localStorage.getItem('passwords')) || [];
      const passwordField = document.getElementById(`password-${index}`);
      const viewBtn = document.getElementById(`viewBtn-${index}`);
      const deleteBtn = document.getElementById(`deleteBtn-${index}`);
      const editBtn = document.getElementById(`editBtn-${index}`);

      if (passwordField.innerText.includes('*')) {
        try {
          const obj = passwords[index];
          const json = await decryptText(obj, masterKey);
          const parsed = JSON.parse(json);
          passwordField.innerText = parsed.password;
          viewBtn.innerText = 'Hide'; editBtn.classList.remove('hidden'); deleteBtn.classList.add('hidden'); viewedIndices.add(index);
        } catch (e) { showErrorNotification('Unable to decrypt.'); }
      } else {
        passwordField.innerText = '*'.repeat(8);
        viewBtn.innerText = 'View'; editBtn.classList.add('hidden'); deleteBtn.classList.remove('hidden'); viewedIndices.delete(index);
      }
    }

    async function deletePassword(index) {
      let passwords = JSON.parse(localStorage.getItem('passwords')) || [];
      passwords.splice(index, 1);
      viewedIndices.delete(index);
      localStorage.setItem('passwords', JSON.stringify(passwords));
      await displayPasswords();
    }

    async function editPassword(index) {
      if (!masterKey) { showErrorNotification('Session locked. Please log in again.'); return; }
      let passwords = JSON.parse(localStorage.getItem('passwords')) || [];
      try {
        const obj = passwords[index];
        const json = await decryptText(obj, masterKey);
        const parsed = JSON.parse(json);
        document.getElementById('site').value = parsed.site;
        document.getElementById('username').value = parsed.username;
        document.getElementById('password').value = parsed.password;
        editingIndex = index;
        document.getElementById('password').type = 'password';
      } catch (e) { showErrorNotification('Unable to decrypt.'); }
    }

    function togglePasswordList() {
      const container = document.getElementById('passwordContainer');
      const searchContainer = document.getElementById('searchContainer');
      const noMatchCard = document.getElementById('noMatchCard');
      container.style.display = container.style.display === 'none' ? 'block' : 'none';
      searchContainer.style.display = container.style.display === 'block' ? 'block' : 'none';
      if (container.style.display === 'none') {
        document.getElementById('searchInput').value = '';
        noMatchCard.classList.add('hidden');
        viewedIndices.clear();
        displayPasswords();
      }
    }

    // Search: decrypt each entry and test (keeps UX, costs CPU intentionally)
    async function searchPasswords() {
      const q = document.getElementById('searchInput').value.toLowerCase();
      const passwordList = document.getElementById('passwordList');
      const passwords = JSON.parse(localStorage.getItem('passwords')) || [];
      const noMatchCard = document.getElementById('noMatchCard');

      passwordList.innerHTML = ''; noMatchCard.classList.add('hidden');
      if (!masterKey) { noMatchCard.classList.remove('hidden'); return; }

      let matchFound = false;
      for (let index = 0; index < passwords.length; index++) {
        try {
          const json = await decryptText(passwords[index], masterKey);
          const parsed = JSON.parse(json);
          if (parsed.site.toLowerCase().includes(q) || parsed.username.toLowerCase().includes(q)) {
            matchFound = true;
            const revealed = viewedIndices.has(index);
            passwordList.innerHTML += `
              <li class='bg-gray-800 p-2 rounded mt-2 flex flex-col'>
                <div class='flex justify-between items-center'>
                  <strong>${escapeHtml(parsed.site)}</strong>
                  <button onclick='togglePasswordDetails(${index})' class='btn btn-view' id='toggleBtn-${index}'>${revealed ? 'üîì' : 'üîí'}</button>
                </div>
                <div id='details-${index}' class='${revealed ? '' : 'hidden'}'>
                  <div>Username: ${escapeHtml(parsed.username)}</div>
                  <div>Password: <span id='password-${index}'>${revealed ? parsed.password : '*'.repeat(8)}</span></div>
                  <div class='action-btns'>
                    <button onclick='revealPassword(${index})' class='btn btn-view' id='viewBtn-${index}'>${revealed ? 'Hide' : 'View'}</button>
                    <button onclick='editPassword(${index})' class='btn btn-edit ${revealed ? '' : 'hidden'}' id='editBtn-${index}'>‚úèÔ∏è</button>
                    <button onclick='deletePassword(${index})' class='btn btn-delete' id='deleteBtn-${index}'>üóë</button>
                  </div>
                </div>
              </li>`;
          }
        } catch (e) { /* skip corrupt entries */ }
      }
      if (!matchFound) { noMatchCard.classList.remove('hidden'); }
    }

    // =========================
    // MENU + EXPORT/IMPORT + LOGOUT
    // =========================

    function toggleMenu(event) {
      event.stopPropagation();
      const slideMenu = document.getElementById('slideMenu');
      slideMenu.classList.toggle('open');
      const menuToggle = document.getElementById('menuToggle');
      menuToggle.style.display = slideMenu.classList.contains('open') ? 'none' : 'flex';
    }

    function closeMenu(event) {
      const slideMenu = document.getElementById('slideMenu');
      if (!slideMenu.contains(event.target) && slideMenu.classList.contains('open')) {
        slideMenu.classList.remove('open');
        document.getElementById('menuToggle').style.display = 'flex';
      }
    }

    function exportData() {
      let passwords = JSON.parse(localStorage.getItem('passwords')) || [];
      const blob = new Blob([JSON.stringify(passwords)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'passwords.json';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      closeMenu({ target: document.body });
    }

    function importData() {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'application/json';
      input.onchange = async (event) => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const passwords = JSON.parse(e.target.result);
            if (!Array.isArray(passwords)) throw new Error('Invalid file');
            localStorage.setItem('passwords', JSON.stringify(passwords));
            await displayPasswords();
          } catch { showErrorNotification('Invalid import file'); }
        };
        reader.readAsText(file);
      };
      input.click();
      closeMenu({ target: document.body });
    }

    function logOut() {
      const slideMenu = document.getElementById('slideMenu');
      slideMenu.classList.remove('open');
      setTimeout(() => {
        const lockAnimation = document.getElementById('lockAnimation');
        const mainCard = document.getElementById('mainCard');
        document.getElementById('menuToggle').style.display = 'none';
        mainCard.classList.add('hidden'); lockAnimation.classList.remove('hidden');
        setTimeout(() => {
          lockAnimation.classList.add('hidden');
          clearInputFields();
          document.getElementById('loginForm').style.display = 'flex';
          document.getElementById('signupForm').style.display = 'none';
          document.getElementById('passwordManager').style.display = 'none';
          document.getElementById('passwordContainer').style.display = 'none';
          document.getElementById('noMatchCard').classList.add('hidden');
          viewedIndices.clear(); editingIndex = -1;
          mainCard.classList.remove('hidden');
          localStorage.setItem('loggedIn','false');
          masterKey = null; clearSessionKey();
          showNotification('Logged out successfully');
        }, 2000);
      }, 300);
    }

    function resetPasswordViews() {
      const passwords = JSON.parse(localStorage.getItem('passwords')) || [];
      passwords.forEach((_, index) => {
        const passwordField = document.getElementById(`password-${index}`);
        const viewBtn = document.getElementById(`viewBtn-${index}`);
        const editBtn = document.getElementById(`editBtn-${index}`);
        const deleteBtn = document.getElementById(`deleteBtn-${index}`);
        if (passwordField && passwordField.innerText !== '*'.repeat(8)) {
          passwordField.innerText = '*'.repeat(8);
          viewBtn.innerText = 'View'; editBtn.classList.add('hidden'); deleteBtn.classList.remove('hidden');
        }
      });
    }

    // UI niceties preserved
    function handleMouseMove(event) {
      const card = document.querySelector('.card');
      const { clientX: x, clientY: y } = event; const { innerWidth: width, innerHeight: height } = window;
      const moveX = ((x - width / 2) / width) * 20; const moveY = ((y - height / 2) / height) * 20;
      card.style.transform = `rotateX(${moveY}deg) rotateY(${moveX}deg)`;
    }

    document.addEventListener('keydown', function(event) {
      if (event.key === 'Enter') {
        if (document.getElementById('loginForm').style.display !== 'none') { login(); }
        else if (document.getElementById('signupForm').style.display !== 'none') { signup(); }
        else if (document.getElementById('passwordManager').style.display !== 'none') { savePassword(); }
      }
    });

    // Helper to avoid HTML injection in rendered fields
    function escapeHtml(str) {
      if (typeof str !== 'string') return str;
      return str.replace(/[&<>"]{/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
    }
  </script>
</body>
</html>